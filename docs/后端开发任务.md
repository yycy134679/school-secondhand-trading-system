* [ ] 1. 项目初始化与准备工作（后端整体）

  * [ ] 1.1 开发环境与基础工具准备

    * [ ] 1.1.1 在开发机安装 Go（建议 ≥ 1.20），并配置 `GOPATH`、`GOROOT`，确认 `go env` 正常。
    * [ ] 1.1.2 安装并启动 PostgreSQL（建议 ≥ 13），创建本地开发数据库实例（如 `secondhand_dev`），记住连接串。
    * [ ] 1.1.3 安装 Redis（可选，用于推荐缓存与状态撤销记录）；如暂不使用，可先预留接口实现内存版。
    * [ ] 1.1.4 安装常用 Go 开发工具：Go 扩展（VSCode/GoLand）、`gofmt` / `goimports`、`golangci-lint`。

  * [ ] 1.2 本地创建项目目录与 Go Module（不从 Git clone）

    * [ ] 1.2.1 在本地创建课程项目根目录 `school-secondhand-trading-system/`，在其中新建子目录 `backend/`，并按项目结构文档准备其他子目录占位（`frontend/`、`admin-frontend/`、`common/` 等）。
    * [ ] 1.2.2 在 `backend/` 目录执行 `go mod init school-secondhand-trading-system/backend`（或你约定的模块名），生成 `go.mod`。
    * [ ] 1.2.3 在 `backend/` 下创建基本目录结构：

      ```text
      backend/
      ├── cmd/
      │   └── main.go
      ├── config/
      ├── router/
      ├── middleware/
      ├── controller/
      │   ├── user/
      │   ├── product/
      │   ├── recommend/
      │   ├── category/
      │   ├── tag/
      │   └── admin/
      ├── service/
      │   ├── user/
      │   ├── product/
      │   ├── recommend/
      │   ├── category/
      │   ├── tag/
      │   └── admin/
      ├── repository/
      ├── model/
      ├── common/
      │   ├── resp/
      │   ├── errors/
      │   ├── auth/
      │   └── util/
      └── .env
      ```

  * [ ] 1.3 基础依赖安装（写入 `go.mod`）

    * [ ] 1.3.1 使用 `go get` 安装核心依赖：Gin、GORM、pg 驱动、JWT、bcrypt、Viper（或其他配置库）、Redis 客户端等：

      * [ ] `github.com/gin-gonic/gin`（Web 框架）
      * [ ] `gorm.io/gorm` + `gorm.io/driver/postgres`（ORM）
      * [ ] `github.com/golang-jwt/jwt/v5`（或等价库，用于 token）
      * [ ] `golang.org/x/crypto/bcrypt`（密码哈希）
      * [ ] `github.com/spf13/viper`（配置）
      * [ ] `github.com/redis/go-redis/v9`（可选，推荐缓存与撤销窗口）
      * [ ] `github.com/go-playground/validator/v10`（结构体参数校验）
    * [ ] 1.3.2 保证 `go.mod` 与文档中的模块划分一致，避免交叉依赖。

  * [ ] 1.4 配置管理与环境文件

    * [ ] 1.4.1 在 `backend/config/config.go` 定义配置结构体：`ServerConfig`（端口、模式）、`DBConfig`（host、port、user、password、dbname、sslmode）、`RedisConfig`、`JWTConfig`（secret、issuer、accessTokenTTL、rememberMeTTL）、`StorageConfig`（本地文件路径或对象存储信息）。
    * [ ] 1.4.2 在项目根或 `backend/` 下创建 `.env`（开发环境），配置：

      ```env
      APP_ENV=development
      HTTP_PORT=8080
      DB_DSN=postgres://user:pass@localhost:5432/secondhand_dev?sslmode=disable
      REDIS_ADDR=localhost:6379
      JWT_SECRET=your-secret
      JWT_ACCESS_TTL=3600
      JWT_REMEMBER_TTL=604800
      FILE_STORAGE_DIR=./uploads
      ```
    * [ ] 1.4.3 在 `config/config.go` 使用 Viper（或自写解析）读取 `.env` 并暴露 `LoadConfig()`。

  * [ ] 1.5 数据库连接与迁移脚本

    * [ ] 1.5.1 在 `backend/config/database.go` 实现 `NewDB(cfg DBConfig) *gorm.DB`：基于 `gorm.io/driver/postgres` 初始化连接池、设置连接池参数。
    * [ ] 1.5.2 将 `sql/schema.sql` 拷贝到 `sql/` 目录下，作为数据库初始化脚本；在开发环境使用 `psql -f schema.sql` 创建表、类型、触发器。
    * [ ] 1.5.3 可选：引入迁移工具（如 goose / migrate），将 `schema.sql` 拆分为 migrations 以支持后续升级。

  * [ ] 1.6 代码规范与运行脚本

    * [ ] 1.6.1 在根或 `backend/` 配置 `.golangci.yml`，启用基础 linters（`govet`, `staticcheck`, `gocyclo` 等）。
    * [ ] 1.6.2 在 `backend/Makefile` 或 `package.json`（若统一）中添加常用命令：`make run`（运行服务）、`make test`（单测）、`make lint`。
    * [ ] 1.6.3 在 `cmd/main.go` 实现应用入口：加载配置 → 初始化日志 → 建立 DB/Redis 连接 → 初始化路由与中间件 → 启动 HTTP 服务。

---

* [ ] 2. 数据库初始化与基础数据准备

  * [ ] 2.1 初始化数据库结构

    * [ ] 2.1.1 在 PostgreSQL 中创建数据库 `secondhand_dev`（或课程指定库名）。
    * [ ] 2.1.2 运行 `sql/schema.sql`，验证创建了类型 `product_status`、表 `users/products/product_images/product_tags/categories/tags/product_conditions/user_recent_views/sessions` 等及相关触发器。
    * [ ] 2.1.3 检查触发器：`products_status_guard`（状态机）、`user_recent_views_prune_after_insert`（最近浏览裁剪）、`trg_set_updated_at`。

  * [ ] 2.2 初始化枚举与基础数据

    * [ ] 2.2.1 向 `product_conditions` 插入新旧程度数据，例如“全新”“九成新”“七成新”，满足 PRD 要求。
    * [ ] 2.2.2 初始化基础分类（教材、数码、生活用品等）和常见标签（如“几乎全新”“价格可小议”），以便前端使用。
    * [ ] 2.2.3 为开发测试手动插入 1~2 个用户（含管理员）和若干商品数据，检查状态机是否生效（尝试非法状态更新应失败）。

---

* [ ] 3. 后端总体架构与基础设施搭建

  * [ ] 3.1 路由总入口与模块拆分

    * [ ] 3.1.1 在 `backend/router/router.go` 定义 `SetupRouter(db *gorm.DB, redis *redis.Client, cfg *config.Config) *gin.Engine`，在其中：注册通用中间件（日志、恢复、CORS）、挂载各模块路由（用户、商品、推荐、分类/标签、后台）。
    * [ ] 3.1.2 为每个模块创建独立路由文件：`router/user.go`、`router/product.go`、`router/category.go`、`router/tag.go`、`router/home.go`、`router/admin.go`，分别绑定到 `/api/v1/users`、`/products`、`/categories`、`/tags`、`/home`、`/admin` 路径。

  * [ ] 3.2 中间件实现

    * [ ] 3.2.1 在 `middleware/logger.go` 使用 Gin Logger 或自定义 logger 记录请求方法、路径、耗时、状态码、请求 ID。
    * [ ] 3.2.2 在 `middleware/recovery.go` 捕获 panic，返回统一错误响应。
    * [ ] 3.2.3 在 `middleware/cors.go` 允许前端域名/端口访问，配置 `Access-Control-Allow-Origin`、`Allow-Headers` 等。
    * [ ] 3.2.4 在 `middleware/auth.go` 实现鉴权：从 `Authorization: Bearer <token>` 解析 JWT，将 `userID`、`isAdmin` 写入 Gin Context；未通过时返回 `code=1002`。
    * [ ] 3.2.5 在 `middleware/admin.go` 检查 `isAdmin`，不满足返回 `code=1003`。

  * [ ] 3.3 公共模块与统一响应

    * [ ] 3.3.1 在 `common/resp/response.go` 定义统一响应结构：`code/message/data`，提供 `Success(ctx, data)` / `Error(ctx, code, msg)` 辅助函数，符合 API 规范。
    * [ ] 3.3.2 在 `common/errors/codes.go` 定义业务错误码常量（1001/1002/1003/2001/2002/3001~3005/4001/4002…），与 `api.md` 保持一致。
    * [ ] 3.3.3 在 `common/auth/jwt.go` 实现 JWT 生成和解析，支持普通登录与“记住我”（不同 TTL）。
    * [ ] 3.3.4 在 `common/auth/password.go` 封装 bcrypt 加密与校验函数。
    * [ ] 3.3.5 在 `common/util/validator.go` 集成 `validator.v10`，实现结构体验证与错误信息转为 `code=1001` + message。

---

* [ ] 4. 用户模块开发（注册 / 登录 / 个人信息 / 密码）

  * [ ] 4.1 模型与仓库层

    * [ ] 4.1.1 在 `model/user.go` 定义 `User` 结构体，对应 `users` 表字段：`ID/Account/Nickname/PasswordHash/AvatarURL/WechatID/IsAdmin/LastNicknameChangedAt/CreatedAt/UpdatedAt`，GORM 标签与 schema 保持一致。
    * [ ] 4.1.2 在 `repository/user_repo.go` 定义接口 `UserRepository` 与实现：

      * [ ] 4.1.2.1 `GetByAccount(ctx, account)`
      * [ ] 4.1.2.2 `GetByID(ctx, id)`
      * [ ] 4.1.2.3 `Create(ctx, user *User)`
      * [ ] 4.1.2.4 `UpdateProfile(ctx, user *User)`（昵称/头像/微信号）
      * [ ] 4.1.2.5 `UpdatePassword(ctx, userID, newHash)`

  * [ ] 4.2 服务层逻辑

    * [ ] 4.2.1 在 `service/user/service.go` 定义 `UserService`，依赖 `UserRepository` 和 auth 工具；实现：

      * [ ] 4.2.1.1 `Register(ctx, account, nickname, password, wechatId *string)`：

        * 校验账号格式（字母数字）、密码长度 ≥ 8、两次密码一致。
        * 检查账号唯一，插入 User，默认 `is_admin=false`。
        * 根据 PRD，注册成功后直接生成 token 并返回，视为自动登录。
      * [ ] 4.2.1.2 `Login(ctx, account, password, remember bool)`：

        * 按账号查询用户，比较密码哈希。
        * 登录成功返回用户信息与 token，带上 `isAdmin` 字段。
      * [ ] 4.2.1.3 `GetProfile(ctx, userID)`：返回当前用户信息。
      * [ ] 4.2.1.4 `UpdateProfile(ctx, userID, nickname, avatarUrl, wechatId)`：

        * 昵称修改需检查与 `last_nickname_changed_at` 间隔 ≥ 30 天，否则返回 `code=1001`。
        * 微信号校验格式（4~64 字符，字母/数字/_/-）。
      * [ ] 4.2.1.5 `ChangePassword(ctx, userID, oldPwd, newPwd)`：旧密码校验成功后更新密码哈希。

  * [ ] 4.3 控制器层与路由

    * [ ] 4.3.1 在 `controller/user/controller.go` 实现以下 Handler，对应 `api.md`：

      * [ ] 4.3.1.1 `POST /api/v1/users/register`：绑定 JSON，调用 `Register`，返回 `{ user, token }`。
      * [ ] 4.3.1.2 `POST /api/v1/users/login`：支持 `rememberMe`，返回 `{ user, token }`。
      * [ ] 4.3.1.3 `GET /api/v1/users/profile`：需要登录，从 ctx 取 userID。
      * [ ] 4.3.1.4 `PUT /api/v1/users/profile`：更新昵称/头像/微信号。
      * [ ] 4.3.1.5 `PUT /api/v1/users/password`：更新密码。
    * [ ] 4.3.2 在 `router/user.go` 注册上述路由，并在需要登录的接口上加 `AuthMiddleware`。

---

* [ ] 5. 商品模块开发（商品主表 / 状态机 / 列表 / 搜索）

  * [ ] 5.1 模型定义（`model/product.go`）

    * [ ] 5.1.1 定义 `Product`，字段映射 `products` 表：`ID/SellerID/Title/Description/Price/ConditionID/CategoryID/Status/MainImageURL/CreatedAt/UpdatedAt`。
    * [ ] 5.1.2 定义 `ProductImage`，映射 `product_images`：`ID/ProductID/URL/SortOrder/IsPrimary`，注意唯一索引约束每商品最多一张主图。
    * [ ] 5.1.3 定义 DTO：`ProductCardDTO`、`ProductDetailDTO` 等，字段参考 `api.md` 中的 `ProductCard`、`ProductDetail`。

  * [ ] 5.2 仓库层（`repository/product_repo.go`）

    * [ ] 5.2.1 `Create(ctx, product *Product, images []ProductImage, tagIDs []int64) (int64, error)`：事务插入 `products`、`product_images`、`product_tags`，设置 `main_image_url`。
    * [ ] 5.2.2 `Update(ctx, product *Product, images []ProductImage, tagIDs []int64, isAdmin bool)`：

      * 普通卖家禁止编辑 `Sold` 商品；管理员在不改 `status` 的前提下可编辑其他字段。
    * [ ] 5.2.3 `GetByID(ctx, id int64)`：联合加载图片与 tags。
    * [ ] 5.2.4 `ListBySeller(ctx, sellerID, keyword, page, pageSize)`：用于“我发布的”列表。
    * [ ] 5.2.5 `UpdateStatus(ctx, id, fromStatus, toStatus)`：带 where 条件，依赖 DB 触发器防非法流转。
    * [ ] 5.2.6 `Search(ctx, params SearchParams)`：实现关键词 + 条件组合搜索，仅 `status=ForSale`。
    * [ ] 5.2.7 `ListLatestForSale(ctx, excludeIDs, page, pageSize)`、`ListByCategory(ctx, categoryID, params)`：供首页和分类页。

  * [ ] 5.3 服务层（`service/product/service.go`）

    * [ ] 5.3.1 `CreateProduct(ctx, sellerID, req)`：

      * 校验必填字段与价格 > 0。
      * 校验 `categoryId` 存在、`tagIds` 合法、`conditionId` 来自 `product_conditions`。
      * 校验卖家 `wechat_id` 非空，否则返回错误码（如 `1001` + 提示“请先完善微信号”）。
      * 处理图片上传（调用统一文件服务获取 URL），构建 `ProductImage` 列表。
      * 设置 `Status=ForSale`，写 DB，返回详情 DTO。
    * [ ] 5.3.2 `UpdateProduct(ctx, actorID, productID, req, isAdmin)`：

      * 检查权限（是否卖家或管理员）；
      * 检查状态：普通卖家禁止编辑 Sold；管理员仅在 `status` 不变时可编辑 Sold 的其他字段；
      * 更新允许字段，支持图片替换或增删。
    * [ ] 5.3.3 `ChangeStatus(ctx, sellerID, productID, action)`：

      * `action` 为 `delist/relist/sold`；
      * 根据当前状态 + 动作映射合法流转：`ForSale→Delisted`、`Delisted→ForSale`、`ForSale→Sold`；
      * Sold 为终态禁止再变更，否则返回 `3004`。
      * 对成功的 `delist/relist` 写入 Redis 撤销记录（键包含 productID + sellerID，TTL 3 秒）。
    * [ ] 5.3.4 `UndoLastStatusChange(ctx, sellerID, productID)`：

      * 从 Redis 读取缓存的 `fromStatus/toStatus`；
      * 若不存在或已超时，返回 `3005`；
      * 若当前状态不等于缓存 `toStatus` 或当前状态为 `Sold`，返回 `3005/3004`；
      * 调用 `UpdateStatus` 将状态回滚，并删除缓存。
    * [ ] 5.3.5 `GetProductDetail(ctx, productID, viewerID *int64)`：

      * 查询详情与关联图片/tags/seller；
      * 若 `viewerID` 非空，调用推荐模块记录浏览；
      * 是否在这里直接返回 `sellerWechat` 由 API 设计决定：根据 `api.md` 使用独立 `/contact` 接口更清晰（详见第 8 节）。
    * [ ] 5.3.6 `ListMyProducts(ctx, sellerID, keyword, page, pageSize)`：返回分页列表。

  * [ ] 5.4 控制器与路由（`controller/product/controller.go` & `router/product.go`）

    * [ ] 5.4.1 映射 `api.md` 商品接口：

      * [ ] 5.4.1.1 `POST /api/v1/products`（登录）：解析 multipart 表单，调用 `CreateProduct`。
      * [ ] 5.4.1.2 `PUT /api/v1/products/:id`（登录）：解析 JSON，调用 `UpdateProduct`。
      * [ ] 5.4.1.3 `POST /api/v1/products/:id/status`（登录）：动作参数 `action`，调用 `ChangeStatus`。
      * [ ] 5.4.1.4 `POST /api/v1/products/:id/status/undo`（登录）：调用 `UndoLastStatusChange`。
      * [ ] 5.4.1.5 `GET /api/v1/products/:id`（公开）：根据是否登录传入 `viewerID`。
      * [ ] 5.4.1.6 `GET /api/v1/products/my`（登录）：调用 `ListMyProducts`。
      * [ ] 5.4.1.7 `GET /api/v1/products/search`（公开）：解析 query，调用 `Search`。
      * [ ] 5.4.1.8 `GET /api/v1/products/category/:categoryId`（公开）。

---

* [ ] 6. 商品图片子模块开发

  * [ ] 6.1 文件存储服务实现（`common/util/file.go`）

    * [ ] 6.1.1 提供 `SaveImage(file multipart.File, header *multipart.FileHeader) (url string, err error)`：将图片保存到 `FILE_STORAGE_DIR` 下并返回可访问 URL。
    * [ ] 6.1.2 做格式与大小校验：限制为 JPG/PNG、最大 2MB。

  * [ ] 6.2 Controller 实现图片管理接口（可与商品 controller 分文件如 `controller/product/image.go`）

    * [ ] 6.2.1 `POST /api/v1/products/:id/images`：

      * 验证当前用户为卖家且商品非 Sold；
      * 上传图片，插入 `product_images` 记录；
      * 若商品无主图，将第一张设为 `is_primary=true` 并更新 `products.main_image_url`。
    * [ ] 6.2.2 `PUT /api/v1/products/:id/images/:imageId/primary`：

      * 将该商品所有图片 `is_primary=false`，再将指定图片设为 true，更新 `products.main_image_url`。
    * [ ] 6.2.3 `PATCH /api/v1/products/:id/images/:imageId`：更新 `sortOrder`。
    * [ ] 6.2.4 `DELETE /api/v1/products/:id/images/:imageId`：删除图片，若删除的是主图则需重新选择一张为主图或置空 `main_image_url`。

---

* [ ] 7. 分类与标签模块开发

  * [ ] 7.1 模型与仓库

    * [ ] 7.1.1 在 `model/category.go`、`model/tag.go` 定义数据结构，映射 `categories`、`tags`。
    * [ ] 7.1.2 在 `repository/category_repo.go`、`repository/tag_repo.go` 实现：

      * `ListAll(ctx)`、`Create(ctx)`、`Update(ctx)`、`Delete(ctx)`；
      * 辅助方法 `CountProductsByCategory(ctx, id)` / `CountProductsByTag(ctx, id)` 用于删除前检查引用。

  * [ ] 7.2 服务层

    * [ ] 7.2.1 `CategoryService`（`service/category/service.go`）：

      * `ListCategories`：供前台使用。
      * `CreateCategory/UpdateCategory/DeleteCategory`：删除前检查引用，多于 0 时返回 `4001`。
    * [ ] 7.2.2 `TagService`：

      * 类似实现，删除前检查 `product_tags` 引用，多于 0 时返回 `4002`。

  * [ ] 7.3 控制器与路由

    * [ ] 7.3.1 前台公开接口：

      * `GET /api/v1/categories`、`GET /api/v1/tags` → 不需登录。
    * [ ] 7.3.2 管理端接口：

      * `POST /api/v1/admin/categories`、`PUT /api/v1/admin/categories/:id`、`DELETE /api/v1/admin/categories/:id`；
      * `POST /api/v1/admin/tags`、`PUT /api/v1/admin/tags/:id`、`DELETE /api/v1/admin/tags/:id`；
      * 所有写操作挂载 `AdminMiddleware`，遵循错误码 `4001/4002`。

---

* [ ] 8. 推荐与浏览记录模块开发

  * [ ] 8.1 浏览记录仓库与模型

    * [ ] 8.1.1 在 `model/view_record.go` 定义 `UserRecentView` 映射 `user_recent_views` 表。
    * [ ] 8.1.2 在 `repository/view_record_repo.go` 实现：

      * `AddView(ctx, userID, productID)`：插入一条记录；
      * `ListRecentViews(ctx, userID, limit)`：按时间倒序返回最近浏览；
      * 由于 DB 已有触发器自动裁剪至 20 条，这里不需手动删除。

  * [ ] 8.2 推荐服务实现（`service/recommend/service.go`）

    * [ ] 8.2.1 实现 `RecordView(ctx, userID, productID)`：在 `GetProductDetail` 中调用，用于写入浏览表。
    * [ ] 8.2.2 实现 `GetRecommendations(ctx, userID, maxCount)`：

      * 优先从 Redis 读取缓存的推荐商品 ID 列表；
      * 若缓存未命中：

        * 从最近浏览表取最近 20 条；
        * 根据这些商品的标签统计频次（可通过 `product_tags` + `tags`）；
        * 查询在售商品中，按标签相关性排序，排除用户自己发布的商品；
        * 取前 `maxCount` 条并写入缓存（设置 TTL）。

  * [ ] 8.3 首页数据服务（`GetHomeData`）

    * [ ] 8.3.1 在推荐服务中实现 `GetHomeData(ctx, userID *int64, page, pageSize)`：

      * 若 `userID` 非空：先取推荐列表；
      * 然后调用 `ProductRepository.ListLatestForSale(excludeIDs=recommendIDs, page, pageSize)` 获取最新在售商品；
      * 若推荐数不足 5 条，用最新在售补齐；
      * 返回 `{ recommendations, latest }`，与 `/api/v1/home` 响应结构对齐。

  * [ ] 8.4 控制器

    * [ ] 8.4.1 在 `controller/recommend/controller.go` 或 `controller/home/controller.go` 实现 `GET /api/v1/home`：

      * 可选读取登录用户 ID；
      * 调用 `GetHomeData`；
      * 返回统一响应。

  * [ ] 8.5 最近浏览接口

    * [ ] 8.5.1 在 `controller/user/controller.go` 添加 `GET /api/v1/users/recent-views`：从浏览记录与商品表联查，返回最近浏览商品卡片。

---

* [ ] 9. 联系卖家模块开发

  * [ ] 9.1 业务规则确认

    * [ ] 9.1.1 根据 PRD/接口文档明确：卖家微信号来自 `users.wechat_id`，为用户级字段；仅在登录且查看者≠卖家时返回。

  * [ ] 9.2 服务层实现

    * [ ] 9.2.1 在 `service/product/service.go` 或独立 `ContactService` 中实现 `GetContactInfo(ctx, viewerID *int64, productID int64)`：

      * 查询商品及 seller；
      * 若未登录（viewerID 为 nil）：返回 `canContact=false`，`sellerWechat=null`，`tips="请先登录后联系卖家"`；
      * 若 viewerID == sellerID：返回 `canContact=false`；前端应隐藏入口；
      * 若 viewerID != sellerID：

        * 若 seller.wechat_id 非空：返回 `canContact=true` + 完整微信号；
        * 若为空（历史数据）：返回 `canContact=false` + `tips="卖家联系方式暂不可用，请稍后再试"`。

  * [ ] 9.3 控制器

    * [ ] 9.3.1 在 `controller/product/controller.go` 添加 `GET /api/v1/products/:id/contact`：

      * 尝试从鉴权中间件获取 `viewerID`，未登录时 viewerID 为空；
      * 调用 `GetContactInfo` 并返回结构 `{ canContact, sellerWechat, tips }`。

---

* [ ] 10. 管理后台 API 模块开发

  * [ ] 10.1 管理员鉴权中间件

    * [ ] 10.1.1 在 `middleware/admin.go` 检查上下文 `isAdmin`，若 false 返回 `code=1003`。

  * [ ] 10.2 仪表盘统计（`AdminService` & `controller/admin/dashboard.go`）

    * [ ] 10.2.1 在 `service/admin/service.go` 实现 `GetDashboardStats(ctx)`：

      * 统计用户总数、商品总数、在售数、已售数等（SELECT COUNT）。
    * [ ] 10.2.2 在 `controller/admin/dashboard.go` 实现 `GET /api/v1/admin/dashboard` 并返回 `{ userCount, productCount, forSaleCount, soldCount }`。

  * [ ] 10.3 后台用户列表

    * [ ] 10.3.1 在 `service/admin/service.go` 实现 `ListUsers(ctx, keyword, page, pageSize)`，根据账号/昵称模糊搜索。
    * [ ] 10.3.2 在 `controller/admin/user.go` 实现 `GET /api/v1/admin/users`。

  * [ ] 10.4 后台商品管理

    * [ ] 10.4.1 在 `service/admin/service.go` 实现 `ListProductsAdmin(ctx, status, sellerId, keyword, page, pageSize)`：支持 status/卖家 ID/关键词过滤。
    * [ ] 10.4.2 在 `controller/admin/product.go` 实现 `GET /api/v1/admin/products`。
    * [ ] 10.4.3 实现 `UpdateProductAsAdmin(ctx, id, req)`：

      * 调用 `ProductRepository.Update`，禁止修改 `status` 字段；
      * 若请求体携带 `status` 或试图改变状态，返回 `3004`。
    * [ ] 10.4.4 在 `controller/admin/product.go` 实现 `PUT /api/v1/admin/products/:id`。

  * [ ] 10.5 后台分类/标签管理

    * [ ] 10.5.1 复用第 7 节的 `CategoryService` / `TagService`，在 `controller/admin/category.go` 与 `controller/admin/tag.go` 中暴露增删改接口。
    * [ ] 10.5.2 删除分类/标签前调用 `CountProducts*`，返回 `4001/4002` 时构造相应 message。

---

* [ ] 11. 安全 / 性能 / 运维相关增强

  * [ ] 11.1 安全方面

    * [ ] 11.1.1 给所有写接口做 CSRF 无关处理（前后端分离 + token 鉴权即可）；
    * [ ] 11.1.2 上传接口限制单请求最大体积（Gin `MaxMultipartMemory`），避免大文件拖垮服务。
    * [ ] 11.1.3 所有 DB 查询使用参数化，避免 SQL 注入；所有错误信息不泄露数据库内部细节。

  * [ ] 11.2 性能与缓存

    * [ ] 11.2.1 在首页推荐与最新列表中合理使用 Redis 缓存结果，避免每次都做复杂 join；设置合适 TTL（5~10 分钟）。
    * [ ] 11.2.2 确保常用查询已按 `schema.sql` 中的索引策略优化（按 `status/created_at/category_id` 等）。

  * [ ] 11.3 日志与监控

    * [ ] 11.3.1 为关键业务（注册、登录、发布商品、状态变更、撤销、联系卖家）打日志，包含 `userID/productID` 与错误码方便排查。

---

* [ ] 12. 接口联调、自测与验收

  * [ ] 12.1 与文档一致性校验

    * [ ] 12.1.1 使用 Postman/Thunder Client/Swagger 对照 `api.md` 的每个接口，检查路径、方法、参数名、响应结构是否 100% 一致。
    * [ ] 12.1.2 特别确认商品状态机相关接口对 `ForSale/Delisted/Sold` 的处理与错误码 `3003/3004/3005` 一致。

  * [ ] 12.2 关键业务流程自测

    * [ ] 12.2.1 流程 1：注册 → 登录 → 修改微信号 → 发布商品 → 首页/搜索/分类可看到该商品 → 详情页点击联系卖家获得微信号。
    * [ ] 12.2.2 流程 2：卖家在“我发布的”中执行：在售 → 下架 → 撤销 → 再下架 → 上架 → 标记已售 → 尝试再上架/撤销/编辑，确保终态不可逆。
    * [ ] 12.2.3 流程 3：已售商品由管理员在后台修改标题/描述/分类/标签，前台详情同步更新，而状态保持为 Sold。
    * [ ] 12.2.4 流程 4：登录用户多次浏览不同标签的商品，检查首页“猜你喜欢”模块是否出现符合标签偏好的商品，并与“最新发布”去重。

  * [ ] 12.3 单元测试与集成测试

    * [ ] 12.3.1 为 UserService / ProductService / RecommendationService 编写核心逻辑单测：状态流转、撤销窗口、昵称频率限制、推荐结果过滤等。
    * [ ] 12.3.2 若时间允许，引入 httptest 编写少量端到端接口测试（注册+登录+发布+搜索）。

  * [ ] 12.4 文档与运维

    * [ ] 12.4.1 更新 `README.md` 中的“后端启动步骤”：环境变量、初始化数据库、运行命令。
    * [ ] 12.4.2 生成最终接口文档（可基于 `api.md` + Swagger 注释），提供给前端同学联调使用。
